<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Noore Cheshm</title>
    <style>
      html, body {
        height: 100%;
        margin: 0;
        background-image: url(background.jpg);
        background-size: cover;
        background-position: center center;
        background-repeat: no-repeat;
        background-attachment: fixed;
        color: #cbd5e1;
      }
      body {
        display: grid;
        place-items: center;
        overflow: hidden;
      }
      canvas {
        width: 100vw;
        height: 100vh;
        image-rendering: pixelated; /* make scaled pixels crisp */
        image-rendering: crisp-edges;
        box-shadow: 0 0 40px transparent inset;
        background: transparent;
        touch-action: none; /* prevent default touch behaviors like scrolling */
        -webkit-touch-callout: none; /* prevent callout on iOS */
        -webkit-user-select: none; /* prevent text selection */
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }
      .hint {
        position: fixed;
        bottom: 20%;
        left: 50%;
        transform: translateX(-50%) rotate(-2deg) skewY(-3deg); /* subtle calligraphic effect */
        font-family: 'Amiri', 'Scheherazade', 'Noto Nastaliq Urdu', 'Lateef', 'Diwan Kufi', 'Diwan Thuluth', 'Arial', serif;
        font-size: 10rem;
        font-weight: 100;
        font-stretch: condensed;
        font-style: normal;
        /* For Arabic/Persian, letter-spacing is often ignored due to ligatures.
           Use 'unicode-bidi: isolate' and 'direction: rtl' to help, and try word-spacing instead. */
        letter-spacing: 0.2em; /* use em for more visible effect */
        word-spacing: -0.6em;  /* negative word spacing to pull glyphs closer */
        line-height: 1.8; /* even more breathing room */
        opacity: 0.30;
        text-align: center;
        user-select: none;
        pointer-events: none;
        background: linear-gradient(90deg, #eaf6ff 0%, #b3d0ff 40%, #a0c4ff 60%, #ffffff 100%);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow:
          0 2px 12px rgba(80,120,200,0.22),
          0 1px 0 #eaf6ff,
          0 0px 0 #b3d0ff;
        -webkit-text-stroke: 1.2px #b3d0ff;
        transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        direction: rtl;
        unicode-bidi: isolate;
      }
      .hint.arranged {
        left: 15%;
        bottom: 10%;
        font-size: 4rem;
      }
      .hint br {
        line-height: 2.8;
        content: "";
        display: block;
        margin: 1.2em 0 1.1em 0; /* even more vertical space between lines */
      }
    </style>
  </head>
  <body>
    <canvas id="sketch"></canvas>
    <div class="hint">نوره<br>چشم</div>

    <script>
      (function () {
        const imgSrc = 'hereye.jpg';
        const canvas = document.getElementById('sketch');
        const dpr = Math.min(2, window.devicePixelRatio || 1);
        const USE_CANVAS_BACKGROUND = false; // keep canvas transparent over body bg
        let isArranged = false; // track animation state
        let animationFrame = null;
        let dotPositions = []; // store final positions for animation
        let currentPositions = []; // current animated positions
        let animationStartTime = 0;
        const ANIMATION_DURATION = 1200; // milliseconds
        let ctx = null; // will be set in render()
        let vw = 0, vh = 0; // viewport dimensions
        let dotMin = 0, dotMax = 0, alphaMin = 0, alphaMax = 0; // drawing params

        // Lightweight animation state (applied to ~70% of dots)
        let animRAF = null;
        let animTime = 0; // seconds
        let lastFrameMs = 0; // for throttling to ~30fps
        let animatedMask = []; // boolean-ish (0/1)
        let twPhase = [], twSpeed = [], twAmp = []; // twinkling params
        let fxPhase = [], fyPhase = [], fxSpeed = [], fySpeed = [], fxAmp = [], fyAmp = []; // float params

        // Optional: allow manual click to set focus center
        let manualFocus = null; // { x, y } in device pixels

        const img = new Image();
        img.src = imgSrc;
        img.onload = () => {
          render();
          window.addEventListener('resize', () => {
            // Debounce a bit to avoid thrashing
            clearTimeout(window.__rAF__);
            window.__rAF__ = setTimeout(render, 80);
          });
        };
        img.onerror = (e) => console.error('Failed to load image:', e);

        // Animation functions (defined outside render for global access)
        function scatterDots() {
          if (animationFrame) cancelAnimationFrame(animationFrame);
          animationStartTime = performance.now();
          
          function animateScatter() {
            const elapsed = performance.now() - animationStartTime;
            const progress = Math.min(elapsed / ANIMATION_DURATION, 1);
            const eased = easeInOutCubic(progress);

            // Animate to random scattered positions with much more spread
            for (let i = 0; i < currentPositions.length; i++) {
              const start = dotPositions[i];
              // Spread dots much further apart, allowing them to go off-screen
              const spreadFactor = 3.5; // increase this for more spread
              const end = { 
                x: (Math.random() - 0.5) * vw * spreadFactor, 
                y: (Math.random() - 0.5) * vh * spreadFactor 
              };
              currentPositions[i] = {
                x: lerp(start.targetX, end.x, eased),
                y: lerp(start.targetY, end.y, eased)
              };
            }

            renderDots();
            
            if (progress < 1) {
              animationFrame = requestAnimationFrame(animateScatter);
            }
          }
          
          animateScatter();
        }

        function arrangeDots() {
          if (animationFrame) cancelAnimationFrame(animationFrame);
          animationStartTime = performance.now();
          
          function animateArrange() {
            const elapsed = performance.now() - animationStartTime;
            const progress = Math.min(elapsed / ANIMATION_DURATION, 1);
            const eased = easeInOutCubic(progress);

            // Animate to proper positions
            for (let i = 0; i < currentPositions.length; i++) {
              const start = currentPositions[i];
              const end = dotPositions[i];
              currentPositions[i] = {
                x: lerp(start.x, end.targetX, eased),
                y: lerp(start.y, end.targetY, eased)
              };
            }

            renderDots();
            
            if (progress < 1) {
              animationFrame = requestAnimationFrame(animateArrange);
            }
          }
          
          animateArrange();
        }

        function renderDots() {
          if (!ctx || dotPositions.length === 0) return;
          
          // Clear canvas
          ctx.clearRect(0, 0, vw, vh);
          
          // Draw all dots at current positions
          ctx.globalCompositeOperation = 'lighter';
          for (let i = 0; i < currentPositions.length; i++) {
            const pos = currentPositions[i];
            const dot = dotPositions[i];
            const w = dot.weight;

            // Precompute base appearance cheaply each frame
            const jitter = 0.95; // fixed to reduce per-frame randomness
            let a = alphaMin + (alphaMax - alphaMin) * Math.pow(w * jitter, 0.7);
            const r = dotMin + (dotMax - dotMin) * Math.pow(w * jitter, 0.5);

            // Movement and twinkle for ~70% of dots
            let dx = 0, dy = 0, tw = 1;
            if (animatedMask[i]) {
              tw = 1 - twAmp[i] + twAmp[i] * (0.5 + 0.5 * Math.sin(animTime * twSpeed[i] + twPhase[i]));
              dx = Math.sin(animTime * fxSpeed[i] + fxPhase[i]) * fxAmp[i];
              dy = Math.sin(animTime * fySpeed[i] + fyPhase[i]) * fyAmp[i];
            }
            a *= tw;

            ctx.globalAlpha = a;
            ctx.fillStyle = dot.color;
            ctx.fillRect(pos.x + dx, pos.y + dy, r, r);

            // Draw micro-cluster if on edge
            if (dot.edge > 0.35) {
              const theta = dot.angle + Math.PI / 2;
              const dx = Math.cos(theta) * r * 0.9;
              const dy = Math.sin(theta) * r * 0.9;
              ctx.fillRect(pos.x + dx, pos.y + dy, r * 0.9, r * 0.9);
              ctx.fillRect(pos.x - dx, pos.y - dy, r * 0.9, r * 0.9);
            }
          }
        }

        function clamp(v, a, b) { return v < a ? a : (v > b ? b : v); }
        function smoothstep(e0, e1, x) {
          const t = clamp((x - e0) / (e1 - e0), 0, 1);
          return t * t * (3 - 2 * t);
        }
        function lerp(a, b, t) { return a + (b - a) * t; }
        function easeInOutCubic(t) {
          return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // Initialize per-dot animation parameters (70% of dots animated)
        function initPerDotAnimation() {
          const n = dotPositions.length;
          animatedMask = new Array(n);
          twPhase = new Array(n); twSpeed = new Array(n); twAmp = new Array(n);
          fxPhase = new Array(n); fyPhase = new Array(n);
          fxSpeed = new Array(n); fySpeed = new Array(n);
          fxAmp = new Array(n); fyAmp = new Array(n);

          for (let i = 0; i < n; i++) {
            const animate = Math.random() > 0.7; // 70%
            animatedMask[i] = animate ? 1 : 0;
            // Small but visible floating (in pixels, scale with dpr)
            const ampBase = 2 * dpr + Math.random() * 3 * dpr;
            fxAmp[i] = ampBase;
            fyAmp[i] = ampBase * (0.6 + Math.random() * 0.8);
            fxSpeed[i] = 0.4 + Math.random() * 0.6; // radians/sec
            fySpeed[i] = 0.4 + Math.random() * 0.6;
            fxPhase[i] = Math.random() * Math.PI * 2;
            fyPhase[i] = Math.random() * Math.PI * 2;
            // Twinkle parameters
            twAmp[i] = 0.50 + Math.random() * 0.60; // modulation
            twSpeed[i] = 0.05 + Math.random() * 0.1; // Hz-ish
            twPhase[i] = Math.random() * Math.PI * 2;
          }
        }

        function startAnimLoop() {
          if (animRAF) cancelAnimationFrame(animRAF);
          animTime = 0;
          lastFrameMs = 0;
          const step = (ts) => {
            if (!lastFrameMs) lastFrameMs = ts;
            const dtMs = ts - lastFrameMs;
            if (dtMs >= 33) { // ~30fps throttle
              animTime += dtMs / 1000;
              renderDots();
              lastFrameMs = ts;
            }
            animRAF = requestAnimationFrame(step);
          };
          animRAF = requestAnimationFrame(step);
        }

        function render() {
          vw = Math.floor(window.innerWidth * dpr);
          vh = Math.floor(window.innerHeight * dpr);
          canvas.width = vw;
          canvas.height = vh;
          ctx = canvas.getContext('2d', { alpha: true, willReadFrequently: true });

          // Ensure transparency each render
          ctx.clearRect(0, 0, vw, vh);

          // Set defaults
          ctx.imageSmoothingEnabled = false;
          ctx.globalCompositeOperation = 'source-over';
          ctx.globalAlpha = 1;

          // Star color helpers: create shades from white -> light blue -> cool blue
          function colorWhiteBlue(t) {
            t = clamp(t, 0, 1);
            // Enhanced range: white -> light blue -> cool blue
            let r, g, b;
            if (t < 0.5) {
              // First half: white to light blue
              const t1 = t * 2;
              r = Math.round(lerp(255, 200, t1));
              g = Math.round(lerp(255, 220, t1));
              b = Math.round(lerp(255, 255, t1));
            } else {
              // Second half: light blue to cool blue
              const t2 = (t - 0.5) * 2;
              r = Math.round(lerp(200, 130, t2));
              g = Math.round(lerp(220, 175, t2));
              b = Math.round(lerp(255, 255, t2));
            }
            return `rgb(${r},${g},${b})`;
          }
          function colorForWeight(localWeight01) {
            // Brighter features lean whiter; dimmer regions lean bluer with randomness
            const base = 0.15 + Math.random() * 0.6;
            const t = clamp(base * (0.65 + 0.35 * (1 - localWeight01)), 0, 1);
            return colorWhiteBlue(t);
          }

          function drawNightSkyBackground() {
            const cx = vw * 0.5;
            const cy = vh * 0.45;
            const r = Math.hypot(vw, vh) * 0.75;
            const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
            g.addColorStop(0, '#091a3f');
            g.addColorStop(1, '#020b22');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, vw, vh);

            const vign = ctx.createRadialGradient(vw * 0.5, vh * 0.5, Math.min(vw, vh) * 0.35, vw * 0.5, vh * 0.5, Math.max(vw, vh));
            vign.addColorStop(0, 'rgba(0,0,0,0)');
            vign.addColorStop(1, 'rgba(0,0,0,0.45)');
            ctx.fillStyle = vign;
            ctx.fillRect(0, 0, vw, vh);

            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = 0.06;
            for (let i = 0; i < 3; i++) {
              const nx = vw * (0.2 + 0.6 * Math.random());
              const ny = vh * (0.2 + 0.6 * Math.random());
              const nr = Math.min(vw, vh) * (0.2 + Math.random() * 0.35);
              const neb = ctx.createRadialGradient(nx, ny, 0, nx, ny, nr);
              neb.addColorStop(0, 'rgba(90,120,180,0.28)');
              neb.addColorStop(1, 'rgba(0,0,0,0)');
              ctx.fillStyle = neb;
              ctx.beginPath();
              ctx.arc(nx, ny, nr, 0, Math.PI * 2);
              ctx.fill();
            }
            ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = 'source-over';
          }

          function drawBackgroundStars() {
            const bgStarCount = Math.max(800, Math.min(3000, Math.round((vw * vh) / 1500)));
            const clusterCount = 4;
            const clusters = [];
            for (let i = 0; i < clusterCount; i++) {
              clusters.push({
                x: Math.random() * vw,
                y: Math.random() * vh,
                r: Math.min(vw, vh) * (0.06 + Math.random() * 0.08)
              });
            }

            ctx.globalCompositeOperation = 'lighter';
            for (let i = 0; i < bgStarCount; i++) {
              let px = Math.random() * vw;
              let py = Math.random() * vh;
              if (Math.random() < 0.25) {
                const c = clusters[(Math.random() * clusterCount) | 0];
                const a = Math.random() * Math.PI * 2;
                const rr = c.r * Math.sqrt(Math.random());
                px = c.x + Math.cos(a) * rr;
                py = c.y + Math.sin(a) * rr;
              }
              const base = 0.04 + Math.random() * 0.18;
              const r = (Math.random() < 0.85 ? 0.35 : 0.9) * dpr;
              ctx.globalAlpha = base;
              // random shade between white and cool blue
              ctx.fillStyle = colorWhiteBlue(Math.random());
              ctx.beginPath();
              ctx.arc(px, py, r, 0, Math.PI * 2);
              ctx.fill();
            }
            ctx.globalAlpha = 1;
          }

          // Draw optional canvas background only if enabled
          if (USE_CANVAS_BACKGROUND) {
            drawNightSkyBackground();
            drawBackgroundStars();
          }

          // Offscreen at natural image resolution for pixel analysis
          const srcW = img.naturalWidth || img.width;
          const srcH = img.naturalHeight || img.height;
          if (!srcW || !srcH) return;

          const off = document.createElement('canvas');
          off.width = srcW;
          off.height = srcH;
          const octx = off.getContext('2d', { willReadFrequently: true });
          octx.drawImage(img, 0, 0, srcW, srcH);
          const { data: src } = octx.getImageData(0, 0, srcW, srcH);

          // Precompute luminance 0..1, simple gradients for edges, and a weight map
          const lum = new Float32Array(srcW * srcH);
          for (let i = 0, p = 0; i < src.length; i += 4, p++) {
            // Perceptual luminance in 0..1
            lum[p] = (0.2126 * src[i] + 0.7152 * src[i + 1] + 0.0722 * src[i + 2]) / 255;
          }

          // Gradient magnitude via central difference, angle for optional micro-clusters
          const grad = new Float32Array(srcW * srcH);
          const ang = new Float32Array(srcW * srcH);
          for (let y = 1; y < srcH - 1; y++) {
            for (let x = 1; x < srcW - 1; x++) {
              const i = y * srcW + x;
              const gx = lum[i + 1] - lum[i - 1];
              const gy = lum[i + srcW] - lum[i - srcW];
              const m = Math.sqrt(gx * gx + gy * gy);
              grad[i] = clamp(m / 1.5, 0, 1); // normalize a bit
              ang[i] = Math.atan2(gy, gx);
            }
          }

          // Build weight map: darker regions + edges dominate. No border feathering (cover mapping)
          const weight = new Float32Array(srcW * srcH);
          const gammaBase = 1.15; // darkness emphasis
          const baseK = 0.70;     // contribution of darkness
          const edgeK = 0.85;     // contribution of edges
          const edgeGamma = 1.0;
          let wMax = 0;
          for (let y = 0; y < srcH; y++) {
            for (let x = 0; x < srcW; x++) {
              const i = y * srcW + x;
              const inv = Math.pow(1 - lum[i], gammaBase);
              const e = Math.pow(grad[i], edgeGamma);
              const v = baseK * inv + edgeK * e;
              weight[i] = v;
              if (v > wMax) wMax = v;
            }
          }
          // Normalize and threshold very low values so bland areas disappear
          const minKeep = 0.02; // below this -> zero so background doesn't fill in
          for (let i = 0; i < weight.length; i++) {
            const v = wMax > 0 ? weight[i] / wMax : 0;
            weight[i] = v > minKeep ? v : 0;
          }

          // Compute weighted centroid (auto focus) biased to strong features
          let sumW = 0, sumX = 0, sumY = 0;
          for (let y = 0; y < srcH; y++) {
            for (let x = 0; x < srcW; x++) {
              const w = weight[y * srcW + x];
              const ww = w * w; // emphasize strong features
              sumW += ww;
              sumX += ww * x;
              sumY += ww * y;
            }
          }
          const cxSrc = sumW > 0 ? (sumX / sumW) : (srcW / 2);
          const cySrc = sumW > 0 ? (sumY / sumW) : (srcH / 2);

          // Map the source to COVER the full viewport (no letterboxing)
          const scale = Math.max(vw / srcW, vh / srcH);
          const offsetX = Math.floor((vw - srcW * scale) / 2);
          const offsetY = Math.floor((vh - srcH * scale) / 2);

          const autoFocusX = offsetX + cxSrc * scale;
          const autoFocusY = offsetY + cySrc * scale;
          const focusX = manualFocus ? manualFocus.x : autoFocusX;
          const focusY = manualFocus ? manualFocus.y : autoFocusY;

          // Stippling: accept-reject sampling weighted by `weight`.
          // Target dot count based on viewport size. Big, but bounded.
          const area = (srcW * scale) * (srcH * scale) / (dpr * dpr);
          const targetDots = Math.round(Math.max(180000, Math.min(1500000, Math.round(area * 0.6))) / 20); // reduce density with division
          
          // Drawing parameters
          ctx.globalCompositeOperation = 'lighter';
          ctx.fillStyle = '#ffffff';
          dotMin = 0.35 * dpr;   // in device pixels
          dotMax = 1.6 * dpr;
          alphaMin = 0.08;
          alphaMax = 0.85;
          const baseBias = 0.002; // small baseline everywhere for a night-sky feel

          // Density falloff parameters (divide probability as distance increases)
          const focusRadiusFrac = 0.38; // radius as a fraction of min(vw,vh)
          const focusStrength = 3.2;    // larger => stronger falloff
          const focusPower = 2.0;       // 2 ~ quadratic

          // Use progressive rendering in animation frames to keep UI responsive
          let drawn = 0;
          const candidatesPerFrame = Math.max(120000, Math.round((vw * vh) / 18000));

          function weightAt(ix, iy) {
            ix = ix | 0; iy = iy | 0;
            if (ix < 0 || iy < 0 || ix >= srcW || iy >= srcH) return 0;
            return weight[iy * srcW + ix];
          }
          function edgeAt(ix, iy) {
            ix = ix | 0; iy = iy | 0;
            if (ix < 1 || iy < 1 || ix >= srcW - 1 || iy >= srcH - 1) return 0;
            return grad[iy * srcW + ix];
          }
          function angleAt(ix, iy) {
            ix = ix | 0; iy = iy | 0;
            if (ix < 1 || iy < 1 || ix >= srcW - 1 || iy >= srcH - 1) return 0;
            return grad[iy * srcW + ix];
          }
          function viewWeight(px, py) {
            const sx = (px - offsetX) / scale;
            const sy = (py - offsetY) / scale;
            const w = weightAt(Math.max(0, Math.min(srcW - 1, sx)), Math.max(0, Math.min(srcH - 1, sy)));
            return clamp(w + baseBias, 0, 1);
          }

          // Generate all dot positions first
          function generateDotPositions() {
            dotPositions = [];
            currentPositions = [];
            let attempts = 0;
            const maxAttempts = targetDots * 10;

            while (dotPositions.length < targetDots && attempts < maxAttempts) {
              attempts++;
              const px = Math.random() * vw;
              const py = Math.random() * vh;
              const w = viewWeight(px, py);
              if (w <= 0) continue;

              const dist = Math.hypot(px - focusX, py - focusY);
              const minDim = Math.min(vw, vh);
              const rNorm = dist / (minDim * focusRadiusFrac);
              const divider = 1 + focusStrength * Math.pow(Math.max(0, rNorm), focusPower);
              const wDiv = w / divider;

              if (Math.random() < wDiv) {
                const sx = (px - offsetX) / scale;
                const sy = (py - offsetY) / scale;
                const edge = (sx >= 1 && sy >= 1 && sx < srcW - 1 && sy < srcH - 1) ? edgeAt(sx, sy) : 0;
                const angle = (sx >= 1 && sy >= 1 && sx < srcW - 1 && sy < srcH - 1) ? angleAt(sx, sy) : 0;

                dotPositions.push({
                  targetX: px, targetY: py,
                  weight: w, edge: edge, angle: angle,
                  sx: sx, sy: sy,
                  color: colorForWeight(w)
                });

                // Start with random scattered positions
                currentPositions.push({
                  x: (Math.random() - 0.5) * vw * 3.5,
                  y: (Math.random() - 0.5) * vh * 3.5
                });
              }
            }
          }

          // Initial setup: generate positions and start scattered
          generateDotPositions();
          // Initial render of scattered dots
          renderDots();
          // Init per-dot animation and start a throttled loop
          initPerDotAnimation();
          startAnimLoop();

                  // Click to re-center density falloff
        window.addEventListener('click', (ev) => {
          console.log('Click detected, isArranged:', isArranged); // debug
          if (isArranged) {
            // Scatter dots randomly
            scatterDots();
          } else {
            // Arrange dots to proper positions
            arrangeDots();
          }
          isArranged = !isArranged;
          
          // Update hint text styling
          const hintElement = document.querySelector('.hint');
          if (hintElement) {
            if (isArranged) {
              hintElement.classList.add('arranged');
            } else {
              hintElement.classList.remove('arranged');
            }
          }
        });

                  // Add touch support for mobile devices
        window.addEventListener('touchstart', (ev) => {
          ev.preventDefault(); // prevent default touch behavior
          console.log('Touch detected, isArranged:', isArranged); // debug
          if (isArranged) {
            // Scatter dots randomly
            scatterDots();
          } else {
            // Arrange dots to proper positions
            arrangeDots();
          }
          isArranged = !isArranged;
          
          // Update hint text styling
          const hintElement = document.querySelector('.hint');
          if (hintElement) {
            if (isArranged) {
              hintElement.classList.add('arranged');
            } else {
              hintElement.classList.remove('arranged');
            }
          }
        }, { passive: false });
        }
      })();
    </script>
  </body>
</html> 